% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flywire-coord.R
\name{flywire2fafb}
\alias{flywire2fafb}
\alias{fafb2flywire}
\title{Map points between FlyWire v1 and FAFB14 space (xyz nm)}
\usage{
flywire2fafb(
  xyz,
  method = c("mapmany", "map1"),
  chunksize = 40000,
  swap = FALSE,
  ...
)

fafb2flywire(
  xyz,
  method = c("mapmany", "map1"),
  chunksize = 40000,
  swap = FALSE,
  ...
)
}
\arguments{
\item{xyz}{A Nx3 matrix of points}

\item{method}{Whether to map many points at once (default) or just one}

\item{chunksize}{The number of points to send to the server when mapping many
points at once.}

\item{swap}{When \code{TRUE} applies the deformation field in the opposite
direction e.g. to give a coarse mapping of points FAFB->FlyWire. This is
wrong but may be useful.}

\item{...}{Additional arguments passed to httr::GET/POST operation}
}
\value{
an Nx3 matrix of points
}
\description{
\code{flywire2fafb} maps points FlyWire->FAFB

\code{fafb2flywire} maps points FAFB->FlyWire
}
\details{
Note that you can also access FlyWire<->FAFB bridging registrations
  via the \code{\link{xform_brain}} series of functions. This will allow you
  to transform most kinds of 3D data objects, whereas the \code{flywire2fafb}
  function is restricted to plain 3D coordinates. See examples.

  Mapping single points is unlikely to be useful, but you may wish to adjust
  the \code{chunksize} argument to send more points at once at the risk of
  possible server timeouts. The default value is quite conservative.

  When \code{swap=TRUE} displacements will be applied in the opposite
  direction to what is intended. This can be used to provide a coarse inverse
  mapping if you feed in FAFB points. This is wrong but was useful before the
  inverse mapping was available as it can get you closer to the right place
  in FlyWire than just assuming that FAFB14 and FlyWire are in the same
  space. This works because deformations are mostly fairly smooth at the
  scale of FAFB-FlyWire displacements. Operationally we find that residual
  displacements are typically of the order 100 nm using this procedure. Since
  2020-08-08 we have a real inverse available, so this is now only of
  historical interest.
}
\examples{
# identified location in FAFB14
p.fafb.nm <- cbind(477042, 284535, 90680)
p.fafb.raw <- p.fafb.nm/c(4,4,40)
# corresponding location in FlyWire
p.flywire.raw <- cbind(118865, 71338, 2267)
p.flywire.nm <- p.flywire.raw * c(4,4,40)

# check displacement
flywire2fafb(p.flywire.nm)-p.fafb.nm

# check what happens when you apply the inverse
fafb2flywire(p.fafb.nm)-p.flywire.nm

data("AV4b1", package='catmaid')
set.seed(42)
before=xyzmatrix(AV4b1)[sample(nvertices(AV4b1), size=2000), ]
after=flywire2fafb(before, swap=TRUE)
d=sqrt(rowSums((before-after)^2))
hist(d, br=20)

\dontrun{
AV4b1.flywire <- xform_brain(AV4b1, reference="FlyWire", sample="FAFB14")
plot3d(neuronlist(AV4b1.flywire, AV4b1))
}
}
