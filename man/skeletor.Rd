% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flywire-skeleton.R
\name{skeletor}
\alias{skeletor}
\alias{reroot_hairball}
\title{Skeletonise neuron meshes using skeletor}
\usage{
skeletor(
  segments = NULL,
  obj = NULL,
  mesh3d = TRUE,
  cloudvolume.url = getOption("fafbseg.cloudvolume.url"),
  clean = TRUE,
  radius = TRUE,
  ratio = 0.1,
  SL = 10,
  WH0 = 2,
  iter_lim = 4,
  epsilon = 0.05,
  precision = 1e-06,
  validate = TRUE,
  method.radii = c("knn", "ray"),
  method = c("vertex_clusters", "edge_collapse"),
  heal = TRUE,
  heal.k = 10L,
  heal.threshold = Inf,
  reroot = TRUE,
  k.soma.search = 10,
  radius.soma.search = 2500,
  brain = NULL,
  n = 5,
  n_rays = 20,
  projection = c("sphere", "tangents"),
  fallback = "knn",
  sampling_dist = 500,
  cluster_pos = c("median", "center"),
  shape_weight = 1,
  sample_weight = 0.1,
  ...
)

reroot_hairball(x, k.soma.search = 10, radius.soma.search = 2500, brain = NULL)
}
\arguments{
\item{segments}{The segment ids to fetch (probably as a character vector),
e.g. flywire IDs or hemibrain bodyids.
Meshes are read from the specified CloudVolume (\code{cloudvolume.url}).}

\item{obj}{character. Path of a \code{obj} file or a folder of such files.
These files are read as meshes and then skeletonised. If \code{segments} is given, this argument is overrriden.}

\item{mesh3d}{logical. If \code{TRUE} then the neuron's volume is added to each \code{neuron} object in the resultant \code{neuronlist]} at \code{neuron$mesh3d}.}

\item{cloudvolume.url}{Optional url from which to fetch meshes normally
specified by the \code{fafbseg.cloudvolume.url} option.}

\item{clean}{logical. If \code{TRUE} then, in python, \code{skeletor.clean} is used
to collapse twigs that have line of sight to each other and ove nodes outside the mesh back inside.
Note that this is not a magic bullet and some of this will not work (well)
if the original mesh was degenerate (e.g. internal faces or not watertight) to begin with.
You will need to have the \code{ncollpyde}
python3 module installed. You can get this with \code{pip3 install ncollpyde}. If you get issues
related to this module, best to set this to \code{FALSE}.}

\item{radius}{logical. Whether or not to return radius information for each skeleton node.
If you want to make use of radii, you will need to have the \code{ncollpyde}
python3 module installed. You can get this with \code{pip3 install ncollpyde}. If you get issues
related to this module, best to set this to \code{FALSE}.}

\item{ratio}{numeric, 0-1. Factor to which to reduce mesh faces. For example,
a ratio of 0.5 will reduce the number of faces to 50 percent.}

\item{SL}{numeric. Factor by which the contraction matrix is multiplied for
each iteration. In theory, lower values are more likely to
get you an optimal contraction at the cost of needing more iterations.}

\item{WH0}{numeric. Initial weight factor for the attraction constraints.
The ratio of the initial weights \code{WL0} (\code{1e-3 * sqrt(A)}) and \code{WH0}
controls the smoothness and the degree of contraction of the
first iteration result, thus it determines the amount of
details retained in subsequent and final contracted meshes.}

\item{iter_lim}{integer. Maximum rounds of contractions.}

\item{epsilon}{numeric. Target contraction rate as measured by the sum of all face
areas in the contracted versus the original mesh. Algorithm
will stop once mesh is contracted below this threshold.
Depending on your mesh (number of faces, shape) reaching a
strong contraction can be extremely costly with comparatively
little benefit for the subsequent skeletonization. Note that
the algorithm might stop short of this target if \code{iter_lim}
is reached first or if the sum of face areas is increasing
from one iteration to the next instead of decreasing.}

\item{precision}{numeric. Sets the precision for finding the least-square solution.
This is the main determinant for speed vs quality: lower
values will take (much) longer but will get you closer to an
optimally contracted mesh. Higher values will be faster but
the iterative contractions might stop early.}

\item{validate}{If \code{True}, will try to fix potential issues with the mesh
(e.g. infinite values, duplicate vertices, degenerate faces)
before collapsing. Degenerate meshes can lead to effectively
infinite runtime for this function!}

\item{method.radii}{the method by which to determine each node's radius. \code{"knn"}
uses k-nearest-neighbors to get radii: fast but potential for being very wrong. \code{"ray"} uses ray-casting to get radii: slower but sometimes less wrong.}

\item{method}{Skeletonisation comes in two flavours with different Pros
and Cons. \code{"vertex_clusters"} groups and collapses vertices based
on their geodesic distance along the mesh's surface. It's
fast and scales well but can lead to oversimplification.
Good for quick & dirty skeletonisations. \code{"edge_collapse"} implements skeleton extraction by edge collapse described Au et al. 2008.
It's rather slow and doesn't scale well but is really good at preserving topology.}

\item{heal}{logical. Whether or not, if the neuron id fragmented, to stitch multiple fragments into single neuron using minimum spanning tree.}

\item{heal.k}{integer. The number of nearest neighbours to consider when trying to merge different clusters.}

\item{heal.threshold}{numeric. The threshold distance above which new vertices will not be connected
(default=Inf disables this feature). This parameter prevents the merging of vertices that are so far away from the main neuron that they are likely to be spurious.}

\item{reroot}{logical. Whether or not to re-root the neuron at an estimated 'soma'. A soma is usually a large ball in the neuron, which will
skeletonise into something of a hair ball. We can try to detect it quickly and reroot the skeleton there. We and do this by finding the nearest leafnodes to each leafnode,
and seeing if they are going off in divergent directions.}

\item{k.soma.search}{integer. The number of leaf nodes to find, around each leaf node of radius \code{radius.soma.search}, for the rerooting process. The larger the number, the better but slower.}

\item{radius.soma.search}{numeric. The distance within which to search for fellow leaf nodes for the rerooting process. Will be inaccurate at values that are too high or too low.
Should be about the size of the expected soma.}

\item{brain}{a \code{mesh3d} or \code{hxsurf} object within which a soma cannot occur. For the re-rooting process. (Insect somata tend to lie outside the brain proper)}

\item{n}{For \code{method.radii == "knn"}. Radius will be the mean over \code{n} nearest-neighbors.}

\item{n_rays}{integer. For \code{method.radii == "knn"}.For \code{method.radii == "ray"}. Number of rays to cast for each node.}

\item{projection}{For \code{method.radii == "ray"}. Whether to cast rays in a sphere around each node or in a circle orthogonally to the node's tangent vector.}

\item{fallback}{For \code{method.radii == "ray"}. If a point is outside or right on the surface of the mesh
the raycasting will return nonesense results. We can either
ignore those cases (\code{"None"}), assign a arbitrary number or
we can fall back to radii from k-nearest-neighbors (\code{"knn"}).}

\item{sampling_dist}{numeric. For \code{method == "vertex_clusters"}. Maximal distance at which vertices are clustered. This
parameter should be tuned based on the resolution of your mesh.}

\item{cluster_pos}{numeric. For \code{method == "vertex_clusters"}. How to determine the x/y/z coordinates of the collapsed
vertex clusters (i.e. the skeleton's nodes). \code{"median"}: Use the vertex closest to cluster's center of mass.
\code{"center"}: Use the center of mass. This makes for smoother skeletons but can lead to nodes outside the mesh.}

\item{shape_weight}{numeric. For \code{method == "edge_collapse"}. Weight for shape costs which penalize collapsing edges that would drastically change the shape of the object.}

\item{sample_weight}{numeric.For \code{method == "edge_collapse"}. Weight for sampling costs which penalize collapses that would generate prohibitively long edges.}

\item{...}{Additional arguments passed to \code{reticulate::py_run_string}.}

\item{x}{a \code{nat::neuron} object.}
}
\value{
A \code{nat::neuronlist} containing neuron skeleton objects.
}
\description{
You can skeletonise complex neuron meshes using skeletor \href{https://github.com/schlegelp/skeletor}{skeletor}.
Skeletor is a python library and this function wraps a series of skeletor functions in order to smoothly process neurons
for use with the \href{http://natverse.org/}{natverse}.
Note, the default settings optimise performance for fast skeletonisation of \href{https://ngl.flywire.ai}{flywire} meshes.
}
\details{
This pipeline:

1. Reads specified meshes from a CloudVolume source.

2. Simplifies each mesh (python: \code{skeletor.simplify})

3. Contract the mesh (python: \code{skeletor.contract})

4. Skeletonises the mesh (python: \code{skeletor.skeletonize})

5. Optionally, cleans the mesh (python: \code{skeletor.clean})

6. Optionally, add radius information to the skeleton (python: \code{skeletor.radii})

7. Optionally, heal the skeleton if there are breaks (\code{nat::stitch_neurons_mst})

8. Optionally, attempts to re-root the neuron at a 'hairball', i.e. approximate the soma (\code{reroot_hairball}).

You will therefore need to have a working python3 install of skeletor, which uses CloudVolume. You do not requir meshparty.
Please install the Python skeletor module as described at: \url{https://github.com/schlegelp/skeletor}. You must ensure that
you are using python3 (implicitly or explicitly) as mesh fetching from
graphene servers depends on this. This should normally work: \code{pip3 install git+git://github.com/schlegelp/skeletor@master}.
If you have already installed skeletor but it is
not found, then I recommend editing your \code{\link{Renviron}} file to set
an environment variable pointing to the correct Python. You can do this
with \code{usethis::edit_r_environ()} and then setting e.g. \code{RETICULATE_PYTHON="/usr/local/bin/python3"}.
(Though best practice would be to create a conda environment
for your natverse R sessions and direct R there using your environ file.)

You will need to set up some kind of authentication in order to fetch volume data for skeletonisation.
See \url{https://github.com/seung-lab/cloud-volume#chunkedgraph-secretjson}
for how to get a token and where to save it. You can either save a json
snippet to \code{~/.cloudvolume/secrets/chunkedgraph-secret.json} or set an
environment variable (\code{CHUNKEDGRAPH_SECRET="XXXX"}.

Finally you will also need to set an option pointing to your server. This is the server hosting th mesh data you are interested in. This
might look something like: \code{options(fafbseg.cloudvolume.url='graphene://https://xxx.dynamicannotationframework.com/segmentation/xxx/xxx')}
and you can easily add this to your startup \code{\link{Rprofile}}
with \code{usethis::edit_r_profile()}. For example, for the flywire data set, it is currently: 'graphene://https://prodv1.flywire-daf.com/segmentation/1.0/fly_v31'
}
\examples{
\dontrun{
choose_segmentation("flywire")
nx=xform_brain(elmr::dense_core_neurons, ref="FlyWire", sample="FAFB14")
xyz =xyzmatrix(nx)
ids = unique(flywire_xyz2id(xyz[sample(1:nrow(xyz),100),]))
neurons = skeletor(ids, brain = elmr::FAFB14.surf)
plot3d(neurons) # note, in flywire space
plot3d(nx, col="black", lwd  =2) # note, in flywire space
}
}
